module player_mode #(
    COLUMN_DIMENSION = 16d16 : COLUMN_DIMENSION > 0,
    ROW_DIMENSION = 16d16 : ROW_DIMENSION > 0,
    PIXEL_COUNT = 16d256 : PIXEL_COUNT > 0,
    BUFFER_SIZE = 1024 : BUFFER_SIZE > 0
) (
    input clk,
    input rst,
    output led[8],
    output io_led[3][8],
    output io_segment[8],
    output io_select[4],
    input io_button[5],
    input io_dip[3][8],
    output data
) {

    const CLK_FREQ = $is_sim() ? 1000 : 100000000;
    const ENCODING_AMOUNT = 4;
    const LEDCOLOR = {24h0F0F0F, 24h030000, 24h000300, 24h000000}; 
    enum States {IDLE, UPDATE_RAM, REFRESH};

    index_reverser index_reverser(#COLUMN_DIMENSION(COLUMN_DIMENSION), #SIZE($clog2(PIXEL_COUNT)));

    .clk(clk){
        .rst(rst){
            data_ram ram(#ROW_DIMENSION(ROW_DIMENSION), #ENCODING_AMOUNT(ENCODING_AMOUNT), 
                #COLUMN_DIMENSION(COLUMN_DIMENSION));
            dff player_x_pos[$clog2(COLUMN_DIMENSION)](#INIT(7));
            dff player_y_pos[$clog2(ROW_DIMENSION)](#INIT(14));
            dff bullet_x[$clog2(COLUMN_DIMENSION)](#INIT(0));
            dff bullet_y[$clog2(ROW_DIMENSION)](#INIT(0));
            dff bullet_active(#INIT(0));
            dff update_ram_flag(#INIT(0));
            dff fsm[$width(States)](#INIT(States.IDLE));
            ws2812b_driver driver(#PIXEL_COUNT(PIXEL_COUNT)); 
            dff cooldown[4](#INIT(0));
            dff bullet_timer[20](#INIT(0));
        }
    }

    button_conditioner movement_button[5](.clk(5x{{clk}}), #CLK_FREQ(5x{{CLK_FREQ}}));
    edge_detector movement_button_edge[5](.clk(5x{{clk}}), #RISE(5x{{1}}), #FALL(5x{{0}}));

    always {
        led = 8h00;           
        io_led = 3x{{8h00}};
        io_segment = 8hff;
        io_select = 4hf;
        data = 0;

        player_x_pos.d = player_x_pos.q;
        player_y_pos.d = player_y_pos.q;
        bullet_x.d = bullet_x.q;
        bullet_y.d = bullet_y.q;
        bullet_active.d = bullet_active.q;
        update_ram_flag.d = update_ram_flag.q;
        fsm.d = fsm.q;
        cooldown.d = cooldown.q > 0 ? cooldown.q - 1 : 0;
        bullet_timer.d = bullet_timer.q + 1;

        ram.address = 0;
        movement_button.in = c{io_button[1], io_button[4], io_button[3], io_button[2], io_button[0]};
        movement_button_edge.in = movement_button.out;
        driver.update = 0;
        driver.clear = 0;

        // Movement Logic
        if (movement_button_edge.out[0] && player_y_pos.q > 11) {
            player_y_pos.d = player_y_pos.q - 1;
        }
        if (movement_button_edge.out[1] && player_y_pos.q < COLUMN_DIMENSION - 2) {
            player_y_pos.d = player_y_pos.q + 1;
        }
        if (movement_button_edge.out[2] && player_x_pos.q < COLUMN_DIMENSION - 2) {
            player_x_pos.d = player_x_pos.q + 1;
        }
        if (movement_button_edge.out[3] && player_x_pos.q > 1) {
            player_x_pos.d = player_x_pos.q - 1;
        }

        // Player shoot logic
        if (movement_button_edge.out[4] && cooldown.q == 0 && !bullet_active.q) {
            bullet_x.d = player_x_pos.q;
            bullet_y.d = player_y_pos.q - 1;//
            bullet_active.d = 1;
            cooldown.d = 10;
            update_ram_flag.d = 1;
        }

        // Bullet movement
        if (bullet_active.q && bullet_timer.q >= 1000000) {
            bullet_timer.d = 0;
            if (bullet_y.q > 0) {
                bullet_y.d = bullet_y.q - 1;
                update_ram_flag.d = 1;
            } else {
                bullet_active.d = 0;
            }
        }

        if (|movement_button_edge.out[3:0] | bullet_active.q) {
            update_ram_flag.d = 1;
        }

        // Send bullet data to RAM
        ram.player_x_pos = player_x_pos.q;
        ram.player_y_pos = player_y_pos.q;
        ram.bullet_x = bullet_x.q;
        ram.bullet_y = bullet_y.q;
        ram.bullet_active = bullet_active.q;
        ram.update = 0;

        index_reverser.input_address = driver.pixel_address;
        ram.address = 0;

        case (fsm.q) {
            States.UPDATE_RAM:
                if (ram.ready & driver.reset) {
                    update_ram_flag.d = 0;
                    fsm.d = States.REFRESH;
                    ram.address = index_reverser.output_address;
                    driver.update = 1;
                }
                led[1:0] = b10;

            States.REFRESH:
                if (driver.next_pixel) {
                    index_reverser.input_address = driver.pixel_address + 1;
                }
                ram.address = index_reverser.output_address;
                if (driver.done) {
                    fsm.d = States.IDLE;
                }
                led[1:0] = b11;

            States.IDLE:
                if (update_ram_flag.q) {
                    fsm.d = States.UPDATE_RAM;
                    ram.update = 1;
                }
                led[1:0] = b01;
                index_reverser.input_address = ram.debug_address_pointer;
        }

        driver.color = LEDCOLOR[ram.out_encoding]; 
        data = driver.data;

        io_led[0] = player_x_pos.q;
        io_led[1] = player_y_pos.q;
        io_led[2] = driver.pixel_address;
        led[7:5] = ram.debug_data;
    }
}
