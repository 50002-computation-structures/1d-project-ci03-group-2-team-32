/*
This module demonstrates the purpose of using a ram, e.g: to update player location
Player is rendered as a square (4 dots)
Each time a new x,y player position is given, we need to store it and also erase the old one 
Now also supports shooting: A single bullet is tracked, moves up automatically, and gets rendered
*/
module data_ram #(
    ROW_DIMENSION = 8 : ROW_DIMENSION > 0,
    COLUMN_DIMENSION = 8 : COLUMN_DIMENSION > 0,
    ENCODING_AMOUNT = 4 : ENCODING_AMOUNT > 0
)(
    input clk,
    input rst,
    input update,
    input player_x_pos[$clog2(COLUMN_DIMENSION)],
    input player_y_pos[$clog2(ROW_DIMENSION)],
    input bullet_x[$clog2(COLUMN_DIMENSION)],
    input bullet_y[$clog2(ROW_DIMENSION)],
    input bullet_active,
    input bullet_color[2],
    input address[$clog2($resize(ROW_DIMENSION*COLUMN_DIMENSION, 16))],
    output out_encoding[2],
    output bullet_color_out[2],
    output is_bullet,   
    output ready,
    output debug_address_pointer[$clog2($resize(ROW_DIMENSION*COLUMN_DIMENSION, 16))],
    output debug_data[3]
) {
    const DEPTH =  $resize(COLUMN_DIMENSION * ROW_DIMENSION, 16)
    enum States {
        INIT, 
        WRITE_TOP,  
        WRITE_BOTTOM_RIGHT, 
        WRITE_BOTTOM_MIDDLE,
        WRITE_BOTTOM_LEFT, 
        ERASE_TOP, 
        ERASE_BOTTOM_MIDDLE,
        ERASE_BOTTOM_LEFT, 
        ERASE_BOTTOM_RIGHT, 
        WRITE_BULLET,
        ERASE_BULLET,
        IDLE
    }
    
    dff fsm[$width(States)](.clk(clk), .rst(rst), #INIT(States.INIT))
    dff player_writer_pointer[$clog2(DEPTH)](.clk(clk), .rst(rst), #INIT(0))
    dff bullet_writer_pointer[$clog2(DEPTH)](.clk(clk), .rst(rst), #INIT(0))
    dff update_flag(#INIT(0), .clk(clk), .rst(rst))
    dff bullet_written(#INIT(0), .clk(clk), .rst(rst))
    dff bullet_last_addr[$clog2(DEPTH)](#INIT(0), .clk(clk), .rst(rst))
    dff stored_bullet_color[2](#INIT(0), .clk(clk), .rst(rst))
    
    const BACKGROUND_COLOR = b00
    const PLAYER_COLOR = b01
    // const BULLET_COLOR = b10
    
    simple_dual_port_ram ram(.rclk(clk), .wclk(clk), #ENTRIES(DEPTH), #WIDTH($clog2(ENCODING_AMOUNT)))
    
    always {
        ram.raddr = 0
        ram.waddr = 0
        ram.write_data = 0
        ram.write_enable = 0
        out_encoding = 0
        debug_data = 0
        bullet_color_out = stored_bullet_color.q // output the stored bullet color
        is_bullet = 0
        debug_data = 0
        
        player_writer_pointer.d = player_writer_pointer.q
        bullet_writer_pointer.d = bullet_writer_pointer.q
        fsm.d = fsm.q
        update_flag.d = update_flag.q
        bullet_written.d = bullet_written.q
        bullet_last_addr.d = bullet_last_addr.q
        stored_bullet_color.d = stored_bullet_color.q
        
        ready = fsm.q == States.IDLE
        
        if (update) {
            update_flag.d = 1
        }
        
        case (fsm.q) {
            States.INIT:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q
                if (player_writer_pointer.q == d0) {
                    ram.write_data = b11
                } else if (player_writer_pointer.q == (COLUMN_DIMENSION-1)) {
                    ram.write_data = b10
                } else if (&player_writer_pointer.q) {
                    ram.write_data = b01
                } else {
                    ram.write_data = BACKGROUND_COLOR
                }
                player_writer_pointer.d = player_writer_pointer.q + 1
                if (&player_writer_pointer.q) {
                    fsm.d = States.WRITE_TOP
                    player_writer_pointer.d = player_y_pos * COLUMN_DIMENSION + player_x_pos
                }
                debug_data = b01
            
            States.ERASE_TOP:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q
                ram.write_data = BACKGROUND_COLOR
                fsm.d = States.ERASE_BOTTOM_MIDDLE
            
            States.ERASE_BOTTOM_MIDDLE:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + COLUMN_DIMENSION
                ram.write_data = BACKGROUND_COLOR
                fsm.d = States.ERASE_BOTTOM_LEFT
            
            States.ERASE_BOTTOM_LEFT:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + 1 + COLUMN_DIMENSION
                ram.write_data = BACKGROUND_COLOR
                fsm.d = States.ERASE_BOTTOM_RIGHT
            
            States.ERASE_BOTTOM_RIGHT:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + COLUMN_DIMENSION - 1
                player_writer_pointer.d = player_y_pos * COLUMN_DIMENSION + player_x_pos
                ram.write_data = BACKGROUND_COLOR
                fsm.d = States.WRITE_TOP
            
            States.WRITE_TOP:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q
                ram.write_data = PLAYER_COLOR
                fsm.d = States.WRITE_BOTTOM_MIDDLE
                debug_data = b10
            
            States.WRITE_BOTTOM_MIDDLE:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + COLUMN_DIMENSION
                ram.write_data = PLAYER_COLOR
                fsm.d = States.WRITE_BOTTOM_LEFT
                debug_data = b10
            
            States.WRITE_BOTTOM_LEFT:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + 1 + COLUMN_DIMENSION
                ram.write_data = PLAYER_COLOR
                fsm.d = States.WRITE_BOTTOM_RIGHT
            
            States.WRITE_BOTTOM_RIGHT:
                ram.write_enable = b1
                ram.waddr = player_writer_pointer.q + COLUMN_DIMENSION - 1
                ram.write_data = PLAYER_COLOR
                if (bullet_active && bullet_written.q) {
                    bullet_writer_pointer.d = bullet_last_addr.q
                    fsm.d = States.ERASE_BULLET
                } else if (bullet_active && !bullet_written.q) {
                    bullet_writer_pointer.d = bullet_y * COLUMN_DIMENSION + bullet_x
                    fsm.d = States.WRITE_BULLET
                } else if (!bullet_active && bullet_written.q) {
                    bullet_writer_pointer.d = bullet_last_addr.q
                    fsm.d = States.ERASE_BULLET
                } else {
                    fsm.d = States.IDLE
                }
            States.ERASE_BULLET:
                ram.write_enable = b1
                ram.waddr = bullet_writer_pointer.q
                ram.write_data = BACKGROUND_COLOR
                bullet_written.d = 0
                fsm.d = States.IDLE
            
            States.WRITE_BULLET:
                ram.write_enable = b1
                ram.waddr = bullet_writer_pointer.q
                ram.write_data = stored_bullet_color.q
                bullet_written.d = 1
                bullet_last_addr.d = bullet_writer_pointer.q
                stored_bullet_color.d = bullet_color
                fsm.d = States.IDLE
            
            States.IDLE:
                ram.raddr = address
                out_encoding = ram.read_data
                debug_data = 0
                if (bullet_written.q && address == bullet_last_addr.q) {
                    is_bullet = 1
                }
                debug_data = 0
                fsm.d = States.IDLE
                if (update_flag.q) {
                    update_flag.d = 0
                    fsm.d = States.ERASE_TOP
                }
                debug_data = c{b11, update_flag.q}
        }
        debug_address_pointer = player_writer_pointer.q
    }
}