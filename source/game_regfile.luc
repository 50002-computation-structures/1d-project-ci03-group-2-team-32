module game_regfile #(
    COLUMN_DIMENSION = 16d16 : COLUMN_DIMENSION > 0,
    ROW_DIMENSION = 16d16 : ROW_DIMENSION > 0,
    PIXEL_COUNT = 16d256 : PIXEL_COUNT > 0,
    BUFFER_SIZE = 1024 : BUFFER_SIZE > 0
) (
    input clk,
    input rst,
    
    input wa[4],          // write address
    input we,             // write enable
    input regfile_data[32],       // data input
    
    input ra1[4],         // read address 1
    input ra2[4],         // read address 2
    
    output rd1[32],       // read data 1
    output rd2[32],       // read data 2
    
    output player_pos_x_out[32],
    output player_pos_y_out[32],
    output player_health_out[32],
    output timer_out[32],
    output score_out[32],
    output sprite_out[32],
    output bullet_color_out[32],
    output player_bullet_x_out[32],
    output player_bullet_y_out[32],
    output enemy_encoding_out[32],
    output stage_counter_out[32],
    output check_right_bound_out[32],
    
    output led[8],
    output io_led[3][8],
    output io_segment[8],
    output io_select[4],
    output data
) {
    
    const ENCODING_AMOUNT = 4
    const LEDCOLOR = {24h0F0F0F, 24h030000, 24h000300, 24h000000} 
    enum States {IDLE, UPDATE_RAM, REFRESH}
    index_reverser index_reverser(#COLUMN_DIMENSION(COLUMN_DIMENSION), #SIZE($clog2(PIXEL_COUNT)))
    
    .clk(clk) {
        .rst(rst) {
            dff player_health[32](#INIT(0))
            dff timer[32](#INIT(0))
            dff score[32](#INIT(0))
            dff sprite[32](#INIT(0))
            dff bullet_color[32](#INIT(0))
            dff enemy_encoding[32](#INIT(0))
            dff stage_counter[32](#INIT(0))
            dff check_right_bound[32](#INIT(0))
            dff cooldown[32](#INIT(0))
            dff bullet_timer[32](#INIT(0))
            dff bullet_active[32](#INIT(0))
            dff update_ram_flag[32](#INIT(1))
            dff fsm[$width(States)](#INIT(States.IDLE))
            
            dff player_x_pos[$clog2(COLUMN_DIMENSION)](#INIT(7))
            dff player_y_pos[$clog2(ROW_DIMENSION)](#INIT(14))
            dff bullet_x[$clog2(COLUMN_DIMENSION)](#INIT(0))
            dff bullet_y[$clog2(ROW_DIMENSION)](#INIT(0))
            
            data_ram ram(#ROW_DIMENSION(ROW_DIMENSION), #ENCODING_AMOUNT(ENCODING_AMOUNT), 
                #COLUMN_DIMENSION(COLUMN_DIMENSION))
            
            ws2812b_driver driver(#PIXEL_COUNT(PIXEL_COUNT))
        }
    }
    
    always {
        // Default UI
        led = 8h00
        io_led = 3x{{8h00}}
        io_segment = 8hff
        io_select = 4hf
        
        // Timer & Cooldown
        cooldown.d = cooldown.q > 0 ? cooldown.q - 1 : 0
        bullet_timer.d = bullet_timer.q + 1
        
        // Write logic
        if (we) {
            case (wa) {
                d0: player_x_pos.d = regfile_data
                d1: player_y_pos.d = regfile_data
                d2: player_health.d = regfile_data
                d3: timer.d = regfile_data
                d4: score.d = regfile_data
                d5: sprite.d = regfile_data
                d6: bullet_color.d =regfile_data
                d7: bullet_x.d = regfile_data
                d8: bullet_y.d = regfile_data
                d9: enemy_encoding.d = regfile_data
                d10: stage_counter.d = regfile_data
                d11: check_right_bound.d = regfile_data
                d12: bullet_timer.d = regfile_data
                d13: bullet_active.d = regfile_data
                d14: cooldown.d = regfile_data
                d15: update_ram_flag.d = regfile_data
            }
        }
        
        // Read logic
        case (ra1) {
            d0: rd1 = player_x_pos.q
            d1: rd1 = player_y_pos.q
            d2: rd1 = player_health.q
            d3: rd1 = timer.q
            d4: rd1 = score.q
            d5: rd1 = sprite.q
            d6: rd1 = bullet_color.q
            d7: rd1 = bullet_x.q
            d8: rd1 = bullet_y.q
            d9: rd1 = enemy_encoding.q
            d10: rd1 = stage_counter.q
            d11: rd1 = check_right_bound.q
            d12: rd1 = bullet_timer.q
            d13: rd1 = bullet_active.q
            d14: rd1 = cooldown.q
            d15: rd1 = update_ram_flag.q
            default: rd1 = 0
        }
        
        case (ra2) {
            d0: rd2 = player_x_pos.q
            d1: rd2 = player_y_pos.q
            d2: rd2 = player_health.q
            d3: rd2 = timer.q
            d4: rd2 = score.q
            d5: rd2 = sprite.q
            d6: rd2 = bullet_color.q
            d7: rd2 = bullet_x.q
            d8: rd2 = bullet_y.q
            d9: rd2 = enemy_encoding.q
            d10: rd2 = stage_counter.q
            d11: rd2 = check_right_bound.q
            d12: rd2 = bullet_timer.q
            d13: rd2 = bullet_active.q
            d14: rd2 = cooldown.q
            d15: rd2 = update_ram_flag.q
            default: rd2 = 0
        }
        
        // Output to game logic
        player_pos_x_out = player_x_pos.q
        player_pos_y_out = player_y_pos.q
        timer_out = timer.q
        score_out = score.q
        sprite_out = sprite.q
        bullet_color_out = bullet_color.q
        player_bullet_x_out = bullet_x.q
        player_bullet_y_out = bullet_y.q
        enemy_encoding_out = enemy_encoding.q
        stage_counter_out = stage_counter.q
        player_health_out = player_health.q
        check_right_bound_out = check_right_bound.q
        update_ram_flag.d = update_ram_flag.q
        fsm.d = fsm.q
        
        // Game display logic
        ram.player_x_pos = player_x_pos.q
        ram.player_y_pos = player_y_pos.q
        ram.bullet_x = bullet_x.q
        ram.bullet_y = bullet_y.q
        ram.bullet_active = bullet_active.q
        ram.update = 0
        
        index_reverser.input_address = driver.pixel_address
        ram.address = 0
        
        driver.update = 0
        driver.clear = 0 // do not clear by default
        
        case (fsm.q) {
            States.UPDATE_RAM:
                if (ram.ready & driver.reset) {
                    update_ram_flag.d = 0
                    fsm.d = States.REFRESH
                    ram.address = index_reverser.output_address
                    driver.update = 1
                }
                led[1:0] = b10
            
            States.REFRESH:
                if (driver.next_pixel) {
                    index_reverser.input_address = driver.pixel_address + 1
                }
                ram.address = index_reverser.output_address
                if (driver.done) {
                    fsm.d = States.IDLE
                }
                led[1:0] = b11
            
            States.IDLE:
                if (update_ram_flag.q) {
                    fsm.d = States.UPDATE_RAM
                    ram.update = 1
                }
                led[1:0] = b01
                index_reverser.input_address = ram.debug_address_pointer
        }
        
        
        
        driver.color = LEDCOLOR[ram.out_encoding]
        //driver.color = 24hFF0000
        data = driver.data
        
        io_led[0] = player_x_pos.q
        io_led[1] = player_y_pos.q
        //io_led[2] = driver.pixel_address
        
       io_led[2][0] = update_ram_flag.q[0]
        io_led[2][1] = ram.ready
        io_led[2][2] = driver.reset
        //io_led[2][3] = driver.update
        //io_led[2][4] = ram.update
        io_led[2][5] = driver.done
        led[7:5] = ram.debug_data
    }
}
