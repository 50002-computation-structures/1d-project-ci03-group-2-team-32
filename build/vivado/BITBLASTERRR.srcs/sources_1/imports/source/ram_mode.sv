/*
    This file was generated automatically by Alchitry Labs 2.0.30-BETA.
    Do not edit this file directly. Instead edit the original Lucid source.
    This is a temporary file and any changes made to it will be destroyed.
*/

module ram_mode #(
        parameter COLUMN_DIMENSION = 16'h10,
        parameter ROW_DIMENSION = 16'h10,
        parameter PIXEL_COUNT = 16'h100,
        parameter BUFFER_SIZE = 12'h800
    ) (
        input wire clk,
        input wire rst,
        output reg [7:0] led,
        output reg [2:0][7:0] io_led,
        output reg [7:0] io_segment,
        output reg [3:0] io_select,
        input wire left_btn,
        input wire right_btn,
        input wire start_btn,
        input wire game_end_flag_out,
        input wire timer_slow_clk_out,
        input wire [31:0] player_pos_x_out,
        input wire [31:0] player_pos_y_out,
        input wire [31:0] bullet_colour_out,
        input wire [31:0] player_bullet_x_out,
        input wire [31:0] player_bullet_y_out,
        input wire bullet_active_out,
        input wire bullet_slow_clk_out,
        input wire fast_clk_out,
        input wire [7:0] enemy_A_x_out,
        input wire [7:0] enemy_A_y_out,
        input wire [7:0] enemy_A_color_out,
        input wire enemy_A_active,
        input wire [7:0] enemy_B_x_out,
        input wire [7:0] enemy_B_y_out,
        input wire [7:0] enemy_B_color_out,
        input wire enemy_B_active,
        input wire [7:0] enemy_C_x_out,
        input wire [7:0] enemy_C_y_out,
        input wire [7:0] enemy_C_color_out,
        input wire enemy_C_active,
        output reg data
    );
    localparam ENCODING_AMOUNT = 4'h8;
    localparam logic [7:0][23:0] LEDCOLOR = {{24'hf030a, 24'h8080e, 24'h80f08, 24'hf0f0f, 24'h30000, 24'h3, 24'h300, 24'h0}};
    localparam _MP_SIZE_1367813415 = $clog2(PIXEL_COUNT);
    localparam _MP_COLUMN_DIMENSION_1367813415 = COLUMN_DIMENSION;
    logic [(_MP_SIZE_1367813415)-1:0] M_index_reverser_input_address;
    logic [(_MP_SIZE_1367813415)-1:0] M_index_reverser_output_address;
    
    index_reverser #(
        .SIZE(_MP_SIZE_1367813415),
        .COLUMN_DIMENSION(_MP_COLUMN_DIMENSION_1367813415)
    ) index_reverser (
        .input_address(M_index_reverser_input_address),
        .output_address(M_index_reverser_output_address)
    );
    
    
    localparam _MP_COLUMN_DIMENSION_732818580 = COLUMN_DIMENSION;
    logic [($clog2(_MP_COLUMN_DIMENSION_732818580 * _MP_COLUMN_DIMENSION_732818580))-1:0] M_rom_animate_address;
    logic [2:0] M_rom_animate_frame0;
    logic [2:0] M_rom_animate_frame1;
    logic [2:0] M_rom_animate_frame2;
    
    game_end_rom #(
        .COLUMN_DIMENSION(_MP_COLUMN_DIMENSION_732818580)
    ) rom_animate (
        .address(M_rom_animate_address),
        .frame0(M_rom_animate_frame0),
        .frame1(M_rom_animate_frame1),
        .frame2(M_rom_animate_frame2)
    );
    
    
    localparam _MP_COLUMN_DIMENSION_434201207 = COLUMN_DIMENSION;
    logic [($clog2(_MP_COLUMN_DIMENSION_434201207 * _MP_COLUMN_DIMENSION_434201207))-1:0] M_start_screen_address;
    logic [2:0] M_start_screen_frame;
    
    init_rom #(
        .COLUMN_DIMENSION(_MP_COLUMN_DIMENSION_434201207)
    ) start_screen (
        .address(M_start_screen_address),
        .frame(M_start_screen_frame)
    );
    
    
    localparam E_States_START_STATE = 1'h0;
    localparam E_States_GAME_STATE = 1'h1;
    localparam _MP_RISE_1901982519 = 1'h1;
    localparam _MP_FALL_1901982519 = 1'h0;
    logic M_bullet_slow_clk_edge_in;
    logic M_bullet_slow_clk_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1901982519),
        .FALL(_MP_FALL_1901982519)
    ) bullet_slow_clk_edge (
        .clk(clk),
        .in(M_bullet_slow_clk_edge_in),
        .out(M_bullet_slow_clk_edge_out)
    );
    
    
    localparam _MP_RISE_865051677 = 1'h1;
    localparam _MP_FALL_865051677 = 1'h0;
    logic M_fast_clk_edge_in;
    logic M_fast_clk_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_865051677),
        .FALL(_MP_FALL_865051677)
    ) fast_clk_edge (
        .clk(clk),
        .in(M_fast_clk_edge_in),
        .out(M_fast_clk_edge_out)
    );
    
    
    localparam _MP_RISE_1190607915 = 1'h1;
    localparam _MP_FALL_1190607915 = 1'h0;
    logic M_slow_clk_edge_in;
    logic M_slow_clk_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1190607915),
        .FALL(_MP_FALL_1190607915)
    ) slow_clk_edge (
        .clk(clk),
        .in(M_slow_clk_edge_in),
        .out(M_slow_clk_edge_out)
    );
    
    
    localparam _MP_RISE_1244310245 = 1'h0;
    localparam _MP_FALL_1244310245 = 1'h1;
    logic M_left_btn_edge_in;
    logic M_left_btn_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_1244310245),
        .FALL(_MP_FALL_1244310245)
    ) left_btn_edge (
        .clk(clk),
        .in(M_left_btn_edge_in),
        .out(M_left_btn_edge_out)
    );
    
    
    localparam _MP_RISE_718375620 = 1'h0;
    localparam _MP_FALL_718375620 = 1'h1;
    logic M_right_btn_edge_in;
    logic M_right_btn_edge_out;
    
    edge_detector #(
        .RISE(_MP_RISE_718375620),
        .FALL(_MP_FALL_718375620)
    ) right_btn_edge (
        .clk(clk),
        .in(M_right_btn_edge_in),
        .out(M_right_btn_edge_out)
    );
    
    
    localparam _MP_ROW_DIMENSION_821178466 = ROW_DIMENSION;
    localparam _MP_COLUMN_DIMENSION_821178466 = COLUMN_DIMENSION;
    localparam _MP_ENCODING_AMOUNT_821178466 = 4'h8;
    logic M_ram_update;
    logic [($clog2(_MP_COLUMN_DIMENSION_821178466))-1:0] M_ram_player_x_pos;
    logic [($clog2(_MP_ROW_DIMENSION_821178466))-1:0] M_ram_player_y_pos;
    logic [2:0] M_ram_bullet_colour_out;
    logic [($clog2(_MP_COLUMN_DIMENSION_821178466))-1:0] M_ram_bullet_x;
    logic [($clog2(_MP_ROW_DIMENSION_821178466))-1:0] M_ram_bullet_y;
    logic M_ram_bullet_active;
    logic [($clog2((5'h10)'(_MP_ROW_DIMENSION_821178466 * _MP_COLUMN_DIMENSION_821178466)))-1:0] M_ram_address;
    logic [($clog2(_MP_COLUMN_DIMENSION_821178466))-1:0] M_ram_enemy_A_x;
    logic [($clog2(_MP_ROW_DIMENSION_821178466))-1:0] M_ram_enemy_A_y;
    logic [2:0] M_ram_enemy_A_color;
    logic M_ram_enemy_A_active;
    logic [($clog2(_MP_COLUMN_DIMENSION_821178466))-1:0] M_ram_enemy_B_x;
    logic [($clog2(_MP_ROW_DIMENSION_821178466))-1:0] M_ram_enemy_B_y;
    logic [2:0] M_ram_enemy_B_color;
    logic M_ram_enemy_B_active;
    logic [($clog2(_MP_COLUMN_DIMENSION_821178466))-1:0] M_ram_enemy_C_x;
    logic [($clog2(_MP_ROW_DIMENSION_821178466))-1:0] M_ram_enemy_C_y;
    logic [2:0] M_ram_enemy_C_color;
    logic M_ram_enemy_C_active;
    logic [2:0] M_ram_out_encoding;
    logic M_ram_ready;
    logic [($clog2((5'h10)'(_MP_ROW_DIMENSION_821178466 * _MP_COLUMN_DIMENSION_821178466)))-1:0] M_ram_debug_address_pointer;
    logic [2:0] M_ram_debug_data;
    
    data_ram #(
        .ROW_DIMENSION(_MP_ROW_DIMENSION_821178466),
        .COLUMN_DIMENSION(_MP_COLUMN_DIMENSION_821178466),
        .ENCODING_AMOUNT(_MP_ENCODING_AMOUNT_821178466)
    ) ram (
        .clk(clk),
        .rst(rst),
        .update(M_ram_update),
        .player_x_pos(M_ram_player_x_pos),
        .player_y_pos(M_ram_player_y_pos),
        .bullet_colour_out(M_ram_bullet_colour_out),
        .bullet_x(M_ram_bullet_x),
        .bullet_y(M_ram_bullet_y),
        .bullet_active(M_ram_bullet_active),
        .address(M_ram_address),
        .enemy_A_x(M_ram_enemy_A_x),
        .enemy_A_y(M_ram_enemy_A_y),
        .enemy_A_color(M_ram_enemy_A_color),
        .enemy_A_active(M_ram_enemy_A_active),
        .enemy_B_x(M_ram_enemy_B_x),
        .enemy_B_y(M_ram_enemy_B_y),
        .enemy_B_color(M_ram_enemy_B_color),
        .enemy_B_active(M_ram_enemy_B_active),
        .enemy_C_x(M_ram_enemy_C_x),
        .enemy_C_y(M_ram_enemy_C_y),
        .enemy_C_color(M_ram_enemy_C_color),
        .enemy_C_active(M_ram_enemy_C_active),
        .out_encoding(M_ram_out_encoding),
        .ready(M_ram_ready),
        .debug_address_pointer(M_ram_debug_address_pointer),
        .debug_data(M_ram_debug_data)
    );
    
    
    localparam _MP_PIXEL_COUNT_1274568056 = PIXEL_COUNT;
    logic M_driver_update;
    logic [23:0] M_driver_color;
    logic M_driver_clear;
    logic [($clog2(_MP_PIXEL_COUNT_1274568056))-1:0] M_driver_pixel_address;
    logic M_driver_data;
    logic M_driver_next_pixel;
    logic M_driver_reset;
    logic M_driver_done;
    
    ws2812b_driver #(
        .PIXEL_COUNT(_MP_PIXEL_COUNT_1274568056)
    ) driver (
        .clk(clk),
        .rst(rst),
        .update(M_driver_update),
        .color(M_driver_color),
        .clear(M_driver_clear),
        .pixel_address(M_driver_pixel_address),
        .data(M_driver_data),
        .next_pixel(M_driver_next_pixel),
        .reset(M_driver_reset),
        .done(M_driver_done)
    );
    
    
    logic [0:0] D_fsm_d, D_fsm_q = 1'h0;
    logic [1:0] D_frame_counter_d, D_frame_counter_q = 0;
    always @* begin
        D_fsm_d = D_fsm_q;
        D_frame_counter_d = D_frame_counter_q;
        
        led = 8'h0;
        io_segment = 8'hff;
        io_select = 4'hf;
        data = 1'h0;
        M_ram_address = 1'h0;
        M_ram_update = 1'h0;
        M_rom_animate_address = 1'h0;
        M_start_screen_address = 1'h0;
        M_driver_update = 1'h0;
        M_driver_clear = 1'h0;
        D_fsm_d = D_fsm_q;
        M_bullet_slow_clk_edge_in = bullet_slow_clk_out;
        M_fast_clk_edge_in = fast_clk_out;
        M_slow_clk_edge_in = timer_slow_clk_out;
        M_left_btn_edge_in = left_btn;
        M_right_btn_edge_in = right_btn;
        
        case (D_fsm_q)
            1'h0: begin
                if (start_btn) begin
                    D_fsm_d = 1'h1;
                end else begin
                    M_start_screen_address = M_index_reverser_output_address;
                    M_driver_color = LEDCOLOR[M_start_screen_frame];
                    if (M_slow_clk_edge_out) begin
                        M_ram_update = 1'h1;
                    end
                    D_fsm_d = 1'h0;
                end
                M_driver_clear = 1'h1;
            end
            1'h1: begin
                if (M_left_btn_edge_out | M_right_btn_edge_out | (bullet_active_out & M_bullet_slow_clk_edge_out) | M_fast_clk_edge_out) begin
                    M_ram_update = 1'h1;
                end
                D_fsm_d = 1'h1;
            end
        endcase
        M_ram_player_x_pos = player_pos_x_out;
        M_ram_player_y_pos = player_pos_y_out;
        M_ram_bullet_x = player_bullet_x_out;
        M_ram_bullet_y = player_bullet_y_out;
        M_ram_bullet_active = bullet_active_out;
        M_ram_bullet_colour_out = bullet_colour_out;
        M_ram_enemy_A_x = enemy_A_x_out;
        M_ram_enemy_A_y = enemy_A_y_out;
        M_ram_enemy_A_color = enemy_A_color_out[2'h2:1'h0];
        M_ram_enemy_A_active = enemy_A_active;
        M_ram_enemy_B_x = enemy_B_x_out;
        M_ram_enemy_B_y = enemy_B_y_out;
        M_ram_enemy_B_color = enemy_B_color_out[2'h2:1'h0];
        M_ram_enemy_B_active = enemy_B_active;
        M_ram_enemy_C_x = enemy_C_x_out;
        M_ram_enemy_C_y = enemy_C_y_out;
        M_ram_enemy_C_color = enemy_C_color_out[2'h2:1'h0];
        M_ram_enemy_C_active = enemy_C_active;
        M_ram_address = M_index_reverser_output_address;
        M_driver_color = LEDCOLOR[M_ram_out_encoding];
        M_index_reverser_input_address = M_driver_pixel_address;
        if (~game_end_flag_out) begin
            M_ram_address = M_index_reverser_output_address;
            M_driver_color = LEDCOLOR[M_ram_out_encoding];
        end else begin
            M_rom_animate_address = M_index_reverser_output_address;
            
            case (D_frame_counter_q)
                2'h0: begin
                    M_driver_color = LEDCOLOR[M_rom_animate_frame0];
                end
                2'h1: begin
                    M_driver_color = LEDCOLOR[M_rom_animate_frame1];
                end
                2'h2: begin
                    M_driver_color = LEDCOLOR[M_rom_animate_frame2];
                end
                default: begin
                    M_driver_color = LEDCOLOR[M_rom_animate_frame2];
                end
            endcase
        end
        if (game_end_flag_out & M_slow_clk_edge_out) begin
            D_frame_counter_d = D_frame_counter_q + 1'h1;
        end else begin
            D_frame_counter_d = D_frame_counter_q;
        end
        M_driver_update = 1'h1;
        data = M_driver_data;
        io_led[1'h0] = enemy_A_color_out;
        io_led[1'h1] = enemy_A_y_out;
        io_led[2'h2] = M_ram_debug_data;
    end
    
    
    always @(posedge (clk)) begin
        if ((rst) == 1'b1) begin
            D_fsm_q <= 1'h0;
            D_frame_counter_q <= 0;
        end else begin
            D_fsm_q <= D_fsm_d;
            D_frame_counter_q <= D_frame_counter_d;
        end
    end
endmodule